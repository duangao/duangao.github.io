<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  <title>BufferLab - 羽加迪姆勒维奥萨</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="description" content="下面是基本的解决方案，详细的文件见我个人github
level 0
首先看test函数内部，发现sub了0x28个字节，因此分配了40个字节，再加上push进去的ebp，一共44个字节，因此填充44个30（就是0），然后将函数smoke的地址08048c90按照小端法写出：90 8c 04 08
执行命令是：
cat 121140013-candle.txt | ./hex2raw |./buf">
<meta property="og:type" content="article">
<meta property="og:title" content="BufferLab">
<meta property="og:url" content="https://duangao.github.io/2014/10/25/BufferLab/index.html">
<meta property="og:site_name" content="羽加迪姆勒维奥萨">
<meta property="og:description" content="下面是基本的解决方案，详细的文件见我个人github
level 0
首先看test函数内部，发现sub了0x28个字节，因此分配了40个字节，再加上push进去的ebp，一共44个字节，因此填充44个30（就是0），然后将函数smoke的地址08048c90按照小端法写出：90 8c 04 08
执行命令是：
cat 121140013-candle.txt | ./hex2raw |./buf">
<meta property="og:image" content="http://image.3001.net/images/20150414/14290128658530.jpg!small">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="BufferLab">
<meta name="twitter:description" content="下面是基本的解决方案，详细的文件见我个人github
level 0
首先看test函数内部，发现sub了0x28个字节，因此分配了40个字节，再加上push进去的ebp，一共44个字节，因此填充44个30（就是0），然后将函数smoke的地址08048c90按照小端法写出：90 8c 04 08
执行命令是：
cat 121140013-candle.txt | ./hex2raw |./buf">
  
  
    <link rel="icon" href="/favicon.png">
  
  <link href="/webfonts/ptserif/main.css" rel='stylesheet' type='text/css'>
  <link href="/webfonts/source-code-pro/main.css" rel="stylesheet" type="text/css">
  <link rel="stylesheet" href="/css/style.css" type="text/css">
  

</head>
<body>
  <div id="container">
    <header id="header">
  <div id="header-outer" class="outer">
    <div id="header-inner" class="inner">
      <a id="main-nav-toggle" class="nav-icon"></a>
      <a id="logo" class="logo" href="/"></a>
      <nav id="main-nav">
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
          <a class="main-nav-link" href="/categories">Categories</a>
        
          <a class="main-nav-link" href="/tags">Tags</a>
        
          <a class="main-nav-link" href="/about">About</a>
        
          <a class="main-nav-link" href="https://duangaolife.github.io">Life(生活博客)</a>
      </nav>
      <nav id="sub-nav">
        <div id="search-form-wrap">
          <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" results="0" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="q" value="site:https://duangao.github.io"></form>
        </div>
      </nav>
    </div>
  </div>
</header>

    <section id="main" class="outer"><article id="post-BufferLab" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 class="article-title" itemprop="name">
      BufferLab
    </h1>
  

      </header>
    
    <div class="article-meta">
      <a href="/2014/10/25/BufferLab/" class="article-date">
  <time datetime="2014-10-24T16:06:12.000Z" itemprop="datePublished">10月 25 2014</time>
</a>
      
  <div class="article-category">
    <a class="article-category-link" href="/categories/program/">program</a>
  </div>

      
    </div>
    <div class="article-entry" itemprop="articleBody">
      
        <p><img src="http://image.3001.net/images/20150414/14290128658530.jpg!small" alt=""><br>下面是基本的解决方案，详细的文件见我个人github</p>
<h1 id="level_0">level 0</h1><ul>
<li>首先看test函数内部，发现sub了0x28个字节，因此分配了40个字节，再加上push进去的ebp，一共44个字节，因此填充44个30（就是0），然后将函数smoke的地址08048c90按照小端法写出：90 8c 04 08</li>
<li>执行命令是：<blockquote>
<p>cat 121140013-candle.txt | ./hex2raw |./bufbomb -u 121140013</p>
</blockquote>
</li>
</ul>
<a id="more"></a>
<h1 id="level_1_sparkler">level 1 sparkler</h1><ul>
<li>首先和level 0的目标是一致的，即让程序不继续执行test而是转而执行fizz，因此也是填充44个字节的30，然后讲fizz的地址填上去</li>
<li>但是也有区别，就是需要将cookie作为参数传递给fizz函数，cookie使用命令</li>
</ul>
<figure class="highlight erlang-repl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">./<span class="function_or_atom">makecookie</span> <span class="number">121140013</span></span><br><span class="line">产生，去查看<span class="function_or_atom">fizz</span>的反汇编代码，发现参数的地址位于<span class="number">0</span>x8(<span class="comment">%ebp),因此，再fizz的地址后面再填充4个30，然后将我们的cookie填上去</span></span><br></pre></td></tr></table></figure>
<ul>
<li>最后，同理执行</li>
</ul>
<blockquote>
<p>cat 121140013-sparkler.txt | ./hex2raw |./bufbomb -u 121140013</p>
</blockquote>
<h1 id="level_2">level 2</h1><h2 id="这里比前面要更复杂一些:">这里比前面要更复杂一些:</h2><ul>
<li>我们首先要得到全局变量global_value的地址，然后修改它的值为cookie</li>
<li>上述修改的代码指令要加在缓冲区内部，然后在ebp上面的返回地址处返回指向缓冲区起始处的地址，这样执行ret的时候就会执行我们写进去<br>的指令了（即修改global_value的的值为cookie）</li>
</ul>
<ol>
<li>我们可以在修改指令的汇编代码中只修改global_value，然后ret，这样的话程序执行完buf处的代码后，还需要回到bang，因此需要在buf地址后面添加bang的地址；</li>
<li>或者，我们再修改的汇编代码中修改完global_value后，将bang的地址入栈，然后ret，这样执行完ret后直接进入bang的位置，因此只需在最后添加buf的地址即可</li>
</ol>
<h2 id="使用gdb_简化操作">使用gdb 简化操作</h2><ul>
<li>上面的指令我们需要人工以汇编的形式写出</li>
<li>然后使用gdb将其翻译为机器码</li>
<li>将上述文件中不满足我们输出格式的部分删除或者注释掉</li>
<li>并且我们想要获得的所有的地址和值信息，都可以通过gdb简单的获取</li>
</ul>
<h2 id="操作记录">操作记录</h2><ul>
<li>global_value的地址：0x804c218</li>
</ul>
<blockquote>
<p>gdb p &amp;global_value</p>
</blockquote>
<ul>
<li>bang的地址:</li>
</ul>
<blockquote>
<p>gdb p bang</p>
</blockquote>
<ul>
<li>buf 的地址（是指ebp-0x28的值，就是说缓冲区的起始地址）</li>
</ul>
<blockquote>
<p>gdb p /x $ebp-0x28</p>
</blockquote>
<ul>
<li>接下来获取修改globa_value的值：</li>
</ul>
<blockquote>
<p>vim level-2.S</p>
</blockquote>
<figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">法<span class="number">1</span></span><br><span class="line">movl <span class="number">$0</span>x6c455538,<span class="number">0x804c218</span> (将cookie的值给global_value的地址处)</span><br><span class="line"><span class="keyword">ret</span></span><br><span class="line">法<span class="number">2</span></span><br><span class="line">movl <span class="number">$0</span>x6c455538,<span class="number">0x804c218</span> (将cookie的值给global_value的地址处)</span><br><span class="line"><span class="keyword">push</span> <span class="number">$0</span>x8048d05</span><br><span class="line"><span class="keyword">ret</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>gcc -m32 -c level-2.S<br>objdump -d level-2.o &gt; level-2.d //此时我们已经获取了它的指令</p>
</blockquote>
<ul>
<li>修改上述文件</li>
</ul>
<p>法1：由于指令已经有11个字节，补33个字节，然后填充buf的地址、bang的地址<br>法2：此时只需补足44字节后填充buf的地址于末尾即可</p>
<h1 id="level_3">level 3</h1><h2 id="简要分析">简要分析</h2><ul>
<li>level 3的提升之处在于这里要保留现场，也就是说在插入攻击代码之后还要恢复原有的栈保留值，进入原来的函数test中去；</li>
<li>题目还要求test返回的值为cookie，而不是原来的1</li>
</ul>
<h2 id="操作步骤">操作步骤</h2><ul>
<li>编写level-3.S<figure class="highlight mel"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">movl <span class="variable">$0</span>x6c455538,<span class="variable">%eax</span></span><br><span class="line">pushl <span class="variable">$0</span>x8048e81</span><br><span class="line">ret</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>解释：</p>
<ul>
<li>首先我们将cookie的值放在%eax中，这就会作为返回值返回；</li>
<li>然后我们将 test中调用getbuf后面紧跟的指令的地址push到栈中（这样执行完攻击代码之后ret的时候就可以回到这里了）</li>
</ul>
<ol>
<li>同上面一样进行gcc -m32 -c以及objdump 得到level-3.d</li>
<li>上面汇编产生的指令为11字节，因此我们补充29个字节，凑成40个字节<br>然后将ebp的值放在后面</li>
</ol>
<figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">p /x (<span class="keyword">int</span>)<span class="literal">ebp</span>解释：这里不可直接pebp ，这样得到的是%<span class="literal">ebp</span>的地址，而我们要保存的是%<span class="literal">ebp</span>这里原本保留的地址，因此将$<span class="literal">ebp</span>转为指针然后解引用</span><br><span class="line">最后面放置buf的地址（同上面，<span class="number">0x55683398</span>）</span><br></pre></td></tr></table></figure>
<h1 id="level_4">level 4</h1><h2 id="分析和介绍">分析和介绍</h2><ul>
<li>level 4的任务同level 3，也是修改test的返回值为cookie，然后从test中返回，区别在于这里其实是testn，调用getbufn，并且在调用的时候要加上-n选项。</li>
<li>这里是模拟在有栈随机化的情况下应该如何展开缓冲区攻击，CSAPP中P 179 有相关内容的理论介绍，简单来说就是通过每次运行的时候在栈空间中随机分配0-n个字节的空间，这段空间仅仅是用来让攻击代码所在的位置（buf）无法直接获取。但是也存在着简单的破解办法，因为这里的n不可能太大，因此我们可以进行很多次实验，选取其中最大的buf地址，然后留出很大的缓冲用nop指令填充，这样不管运行时实际的buf在哪里，都可以跳入到这一片的nop中，然后顺势进入我们的攻击代码</li>
</ul>
<h2 id="实际步骤">实际步骤</h2><ul>
<li>首先写出level-4.S<figure class="highlight mel"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">movl <span class="variable">$0</span>x6c455538,<span class="variable">%eax</span></span><br><span class="line">leal <span class="number">0x28</span>(<span class="variable">%esp</span>),<span class="variable">%ebp</span></span><br><span class="line">pushl <span class="variable">$0</span>x8048e81</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>基本上同level-3，加了一句leal指令，用于恢复%ebp的值，ebp总是相对esp偏移0x28，因此我们可以通过leal指令确定每次运行时的%ebp</p>
<ul>
<li>gcc -c以及objdump 得到level-4.d</li>
<li>由于在getbufn中分配了520个字节的buf空间，加上push进去的变量，一共524个字节需要填充，而上面产生的指令有15个字节，因此在文件开头添加509个nop，然后在末尾添加buf的地址</li>
<li>buf的地址显然是不确定的值，我们在gdb中调试，加上-n选项<br>然后不断的p $ebp-0x208来得到每次运行时的buf地址，发现为：<br>0x55683138(2次)、0x55683148、0x556831b8、0x55683208，选取其中的最大的地址:0x55683208,添加到攻击代码的末尾</li>
</ul>
<blockquote>
<p>选取最大的地址才可以保证进入我们设置的nop缓冲中去</p>
</blockquote>

      
    </div>
  
    <footer class="article-footer">
      
    </footer>
  
  </div>
  
    
<nav id="article-nav">
  
    <a href="/2014/12/18/拓扑排序的两种做法/" id="article-nav-newer" class="article-nav-link-wrap">
      <div class="article-nav-title"><span>&lt;</span>&nbsp;
        
          拓扑排序的两种做法
        
      </div>
    </a>
  
  
    <a href="/2014/09/15/递归下降求解中缀、后缀、前缀表达式/" id="article-nav-older" class="article-nav-link-wrap">
      <div class="article-nav-title">递归下降求解中缀、后缀、前缀表达式&nbsp;<span>&gt;</span></div>
    </a>
  
</nav>

  
</article>

</section>
    <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
   	 Email: gaoduan0306@gmail.com  gaoduan0306@163.com 		</br>
   	 <a href="http://www.cnblogs.com/gaoduan/">cnblog</a>.   </br>
	 <a href="https://duangaolife.github.io">Life Blog</a>
    </div>
  </div>
</footer>

    

<script src="/js/jquery.min.js"></script>


  <link rel="stylesheet" href="/fancybox/jquery.fancybox.css" type="text/css">
  <script src="/fancybox/jquery.fancybox.pack.js" type="text/javascript"></script>


<script src="/js/script.js" type="text/javascript"></script>

  </div>
</body>
</html>